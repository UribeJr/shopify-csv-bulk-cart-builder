{% comment %}
  Bulky Cart Builder Block
  Based on Figma design with modern UI components
{% endcomment %}

<style>
/* Figma Design System - Bulky Cart Builder */
:root {
  --font-size: 14px;
  --background: #ffffff;
  --foreground: oklch(0.145 0 0);
  --card: #ffffff;
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: #030213;
  --primary-foreground: oklch(1 0 0);
  --secondary: oklch(0.95 0.0058 264.53);
  --secondary-foreground: #030213;
  --muted: #ececf0;
  --muted-foreground: #717182;
  --accent: #e9ebef;
  --accent-foreground: #030213;
  --destructive: #d4183d;
  --destructive-foreground: #ffffff;
  --border: rgba(0, 0, 0, 0.1);
  --input: transparent;
  --input-background: #f3f3f5;
  --switch-background: #cbced4;
  --font-weight-medium: 500;
  --font-weight-normal: 400;
  --ring: oklch(0.708 0 0);
  --radius: 0.3rem;
  
  /* Typography scale */
  --text-xs: 0.75rem;
  --text-sm: 0.875rem;
  --text-base: 1rem;
  --text-lg: 1.125rem;
  --text-xl: 1.25rem;
  --text-2xl: 1.5rem;
  --text-3xl: 1.875rem;
  --text-4xl: 2.25rem;
  --text-5xl: 3rem;
  --text-6xl: 3.75rem;
  
  /* Spacing scale */
  --spacing-1: 0.25rem;
  --spacing-2: 0.5rem;
  --spacing-3: 0.75rem;
  --spacing-4: 1rem;
  --spacing-6: 1.5rem;
  --spacing-8: 2rem;
  --spacing-12: 3rem;
}

/* Base styles - scoped to cart builder only */
.cart-builder-container * {
  box-sizing: border-box;
}

/* Utility classes - scoped to cart builder */
.cart-builder-container .w-full { width: 100%; }
.cart-builder-container .max-w-6xl { max-width: 72rem; }
.cart-builder-container .mx-auto { margin-left: auto; margin-right: auto; }
.cart-builder-container .p-6 { padding: 1.5rem; }
.cart-builder-container .space-y-8 > * + * { margin-top: 2rem; }
.cart-builder-container .text-center { text-align: center; }
.cart-builder-container .space-y-4 > * + * { margin-top: 1rem; }
.cart-builder-container .text-3xl { font-size: 1.875rem; }
.cart-builder-container .font-semibold { font-weight: 600; }
.cart-builder-container .text-foreground { color: #000; }
.cart-builder-container .text-muted-foreground { color: #666; }
.cart-builder-container .max-w-2xl { max-width: 42rem; }
.cart-builder-container .relative { position: relative; margin-bottom: 20px;}
.cart-builder-container .absolute { position: absolute; }
.cart-builder-container .top-full { top: 100%; }
.cart-builder-container .left-0 { left: 0; }
.cart-builder-container .right-0 { right: 0; }
.cart-builder-container .mt-2 { margin-top: 0.5rem; }
.cart-builder-container .z-50 { z-index: 50; }
.cart-builder-container .max-h-96 { max-height: 24rem; }
.cart-builder-container .overflow-y-auto { overflow-y: auto; }
.cart-builder-container .p-2 { padding: 0.5rem; }
.cart-builder-container .flex { display: flex; }
.cart-builder-container .items-center { align-items: center; }
.cart-builder-container .justify-between { justify-content: space-between; }
.cart-builder-container .p-3 { padding: 0.75rem; }
.cart-builder-container .hover\:bg-accent:hover { background-color: #f3f4f6; }
.cart-builder-container .rounded-lg { border-radius: 0.5rem; }
.cart-builder-container .transition-colors { transition: color 0.15s ease-in-out; }
.cart-builder-container .flex-1 { flex: 1 1 0%; }
.cart-builder-container .space-y-1 > * + * { margin-top: 0.25rem; }
.cart-builder-container .gap-2 { gap: 0.5rem; }
.cart-builder-container .font-medium { font-weight: 500; }
.cart-builder-container .text-xs { font-size: 0.75rem; }
.cart-builder-container .gap-4 { gap: 1rem; }
.cart-builder-container .text-sm { font-size: 0.875rem; }
.cart-builder-container .border { border: 1px solid #d1d5db; }
.cart-builder-container .rounded-lg { border-radius: 0.5rem; }
.cart-builder-container .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
.cart-builder-container .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
.cart-builder-container .hover\:bg-accent:hover { background-color: #f3f4f6; }
.cart-builder-container .rounded-l-lg { border-top-left-radius: 0.5rem; border-bottom-left-radius: 0.5rem; }
.cart-builder-container .px-3 { padding-left: 3rem; padding-right: 3rem; }
.cart-builder-container .min-w-\[3rem\] { min-width: 3rem; }
.cart-builder-container .text-center { text-align: center; }
.cart-builder-container .border-x { border-left: 1px solid #d1d5db; border-right: 1px solid #d1d5db; }
.cart-builder-container .rounded-r-lg { border-top-right-radius: 0.5rem; border-bottom-right-radius: 0.5rem; }
.cart-builder-container .gap-1 { gap: 0.25rem; }
.cart-builder-container .w-3 { width: 0.75rem; }
.cart-builder-container .h-3 { height: 0.75rem; }
.cart-builder-container .w-4 { width: 1rem; }
.cart-builder-container .h-4 { height: 1rem; }
.cart-builder-container .gap-4 { gap: 1rem; }
.cart-builder-container .overflow-x-auto { overflow-x: auto; }
.cart-builder-container .w-full { width: 100%; }
.cart-builder-container .border-b { border-bottom: 1px solid #d1d5db; }
.cart-builder-container .text-left { text-align: left; }
.cart-builder-container .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
.cart-builder-container .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
.cart-builder-container .font-medium { font-weight: 500; }
.cart-builder-container .text-right { text-align: right; }
.cart-builder-container .text-center { text-align: center; }
.cart-builder-container .hover\:bg-accent\/50:hover { background-color: rgba(243, 244, 246, 0.5); }
.cart-builder-container .py-4 { padding-top: 1rem; padding-bottom: 1rem; }
.cart-builder-container .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
.cart-builder-container .rounded { border-radius: 0.25rem; }
.cart-builder-container .font-mono { font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace; }
.cart-builder-container .w-24 { width: 6rem; }
.cart-builder-container .border-0 { border: 0; }
.cart-builder-container .h-8 { height: 2rem; }
.cart-builder-container .group { }
.cart-builder-container .group:hover .group-hover\:opacity-100 { opacity: 1; }
.cart-builder-container .opacity-0 { opacity: 0; }
.cart-builder-container .transition-opacity { transition: opacity 0.15s ease-in-out; }
.cart-builder-container .justify-center { justify-content: center; }
.cart-builder-container .text-destructive { color: #dc2626; }
.cart-builder-container .hover\:text-destructive:hover { color: #dc2626; }
.cart-builder-container .hover\:bg-destructive\/10:hover { background-color: rgba(220, 38, 38, 0.1); }
.cart-builder-container .pt-4 { padding-top: 1rem; }
.cart-builder-container .mt-4 { margin-top: 1rem; }
.cart-builder-container .border-t { border-top: 1px solid #d1d5db; }
.cart-builder-container .font-semibold { font-weight: 600; }
.cart-builder-container .text-lg { font-size: 1.125rem; }
.cart-builder-container .disabled\:opacity-50:disabled { opacity: 0.5; }
.cart-builder-container .disabled\:cursor-not-allowed:disabled { cursor: not-allowed; }
.cart-builder-container .disabled\:bg-muted:disabled { background-color: #f3f4f6; }
.cart-builder-container .disabled\:text-muted-foreground:disabled { color: #666; }
.cart-builder-container .disabled\:border-muted:disabled { border-color: #f3f4f6; }

/* Button styles - scoped to cart builder */
.cart-builder-container .btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem;
  font-weight: 500;
  transition: all 0.15s ease-in-out;
  cursor: pointer;
  border: none;
  padding: 0.5rem 1rem;
  font-size: 14px;
  line-height: 1.5;
}

.cart-builder-container .btn-primary {
  background-color: #000;
  color: #fff;
}

.cart-builder-container .btn-primary:hover {
  background-color: #000;
  opacity: 0.9;
}

.cart-builder-container .btn-secondary {
  background-color: #f3f4f6;
  color: #000;
  border: 1px solid #d1d5db;
}

.cart-builder-container .btn-secondary:hover {
  background-color: #e5e7eb;
}

.cart-builder-container .btn-sm {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
}

.cart-builder-container .btn-outline {
  background-color: transparent;
  border: 1px solid #d1d5db;
  color: #000;
}

.cart-builder-container .btn-outline:hover {
  background-color: #f3f4f6;
}

.cart-builder-container .btn-ghost {
  background-color: transparent;
  color: #000;
}

.cart-builder-container .btn-ghost:hover {
  background-color: #f3f4f6;
}

/* Input styles */
.input {
  display: flex;
  height: 2.5rem;
  width: 100%;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background-color: var(--input-background);
  padding: var(--spacing-2) var(--spacing-3);
  font-size: var(--font-size);
  transition: border-color 0.15s ease-in-out;
}

.input:focus {
  outline: none;
  border-color: var(--ring);
  box-shadow: 0 0 0 2px rgba(3, 2, 19, 0.1);
}

/* Card styles */
.card {
  background-color: var(--card);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
}

.card-header {
  padding: var(--spacing-6);
  border-bottom: 1px solid var(--border);
}

.card-title {
  font-size: 1.125rem;
  font-weight: var(--font-weight-medium);
  color: var(--card-foreground);
}

.card-content {
  padding: var(--spacing-6);
}

/* Badge styles */
.badge {
  display: inline-flex;
  align-items: center;
  border-radius: 0.375rem;
  font-size: 0.75rem;
  font-weight: var(--font-weight-medium);
  padding: var(--spacing-1) var(--spacing-2);
}

.badge-secondary {
  background-color: var(--secondary);
  color: var(--secondary-foreground);
}

.badge-outline {
  background-color: transparent;
  border: 1px solid var(--border);
  color: var(--foreground);
}

/* Table styles */
.table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
}

.table th,
.table td {
  padding: var(--spacing-2) var(--spacing-1);
  text-align: left;
  border-bottom: 1px solid var(--border);
  vertical-align: middle;
}

.table th {
  font-weight: var(--font-weight-medium);
  color: var(--muted-foreground);
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Compact table for better fit */
.table td {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 0;
}

.table td:first-child {
  max-width: 250px;
  white-space: normal;
}

.table td:nth-child(2) {
  max-width: 150px;
}

.table td:nth-child(3) {
  max-width: 100px;
}

.table td:nth-child(4) {
  max-width: 100px;
}

.table td:nth-child(5) {
  max-width: 100px;
}

.table td:nth-child(6) {
  max-width: 150px;
}

.table td:last-child {
  max-width: 80px;
}

/* Search icon */
.search-icon {
  position: absolute;
  left: var(--spacing-3);
  top: 50%;
  transform: translateY(-50%);
  color: var(--muted-foreground);
  width: 1rem;
  height: 1rem;
}

/* Loading spinner animation */
@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.animate-spin {
  animation: spin 1s linear infinite;
}

/* Text size variants */
.cart-builder-container.text-size-small {
  --font-size: 14px;
  --text-xs: 0.75rem;
  --text-sm: 0.875rem;
  --text-base: 1rem;
  --text-lg: 1.125rem;
  --text-xl: 1.25rem;
  --text-2xl: 1.5rem;
  --text-3xl: 1.875rem;
  --text-4xl: 2.25rem;
  --text-5xl: 3rem;
  --text-6xl: 3.75rem;
}

.cart-builder-container.text-size-medium {
  --font-size: 18px;
  --text-xs: 1rem;
  --text-sm: 1.125rem;
  --text-base: 1.25rem;
  --text-lg: 1.5rem;
  --text-xl: 1.75rem;
  --text-2xl: 2rem;
  --text-3xl: 2.5rem;
  --text-4xl: 3rem;
  --text-5xl: 3.75rem;
  --text-6xl: 4.5rem;
}

.cart-builder-container.text-size-large {
  --font-size: 22px;
  --text-xs: 1.25rem;
  --text-sm: 1.375rem;
  --text-base: 1.5rem;
  --text-lg: 1.75rem;
  --text-xl: 2rem;
  --text-2xl: 2.5rem;
  --text-3xl: 3rem;
  --text-4xl: 3.5rem;
  --text-5xl: 4.25rem;
  --text-6xl: 5rem;
}

/* Override utility classes with text size variants */
.cart-builder-container.text-size-medium .text-xs { font-size: var(--text-xs) !important; }
.cart-builder-container.text-size-medium .text-sm { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-medium .text-base { font-size: var(--text-base) !important; }
.cart-builder-container.text-size-medium .text-lg { font-size: var(--text-lg) !important; }
.cart-builder-container.text-size-medium .text-xl { font-size: var(--text-xl) !important; }
.cart-builder-container.text-size-medium .text-2xl { font-size: var(--text-2xl) !important; }
.cart-builder-container.text-size-medium .text-3xl { font-size: var(--text-3xl) !important; }
.cart-builder-container.text-size-medium .text-4xl { font-size: var(--text-4xl) !important; }
.cart-builder-container.text-size-medium .text-5xl { font-size: var(--text-5xl) !important; }
.cart-builder-container.text-size-medium .text-6xl { font-size: var(--text-6xl) !important; }

.cart-builder-container.text-size-large .text-xs { font-size: var(--text-xs) !important; }
.cart-builder-container.text-size-large .text-sm { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-large .text-base { font-size: var(--text-base) !important; }
.cart-builder-container.text-size-large .text-lg { font-size: var(--text-lg) !important; }
.cart-builder-container.text-size-large .text-xl { font-size: var(--text-xl) !important; }
.cart-builder-container.text-size-large .text-2xl { font-size: var(--text-2xl) !important; }
.cart-builder-container.text-size-large .text-3xl { font-size: var(--text-3xl) !important; }
.cart-builder-container.text-size-large .text-4xl { font-size: var(--text-4xl) !important; }
.cart-builder-container.text-size-large .text-5xl { font-size: var(--text-5xl) !important; }
.cart-builder-container.text-size-large .text-6xl { font-size: var(--text-6xl) !important; }

/* Override specific elements that need font size adjustments */
.cart-builder-container.text-size-medium .btn { font-size: var(--font-size) !important; }
.cart-builder-container.text-size-medium .btn-sm { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-medium .input { font-size: var(--font-size) !important; }
.cart-builder-container.text-size-medium .card-title { font-size: var(--text-lg) !important; }
.cart-builder-container.text-size-medium .table { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-medium .table th { font-size: var(--text-xs) !important; }
.cart-builder-container.text-size-medium .badge { font-size: var(--text-xs) !important; }

.cart-builder-container.text-size-large .btn { font-size: var(--font-size) !important; }
.cart-builder-container.text-size-large .btn-sm { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-large .input { font-size: var(--font-size) !important; }
.cart-builder-container.text-size-large .card-title { font-size: var(--text-lg) !important; }
.cart-builder-container.text-size-large .table { font-size: var(--text-sm) !important; }
.cart-builder-container.text-size-large .table th { font-size: var(--text-xs) !important; }
.cart-builder-container.text-size-large .badge { font-size: var(--text-xs) !important; }

/* Highlight style for out-of-stock rows in the shopping list */
.oos-highlight {
  background-color: #fff1f2; /* rose-50 */
  position: relative;
}
.oos-highlight::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background-color: #ef4444; /* red-500 */
}

/* Modal specific styles */
#variant-modal {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  z-index: 9999 !important;
  background-color: rgba(0, 0, 0, 0.5) !important;
  display: none !important; /* Hidden by default */
  align-items: center !important;
  justify-content: center !important;
}

#variant-modal.show {
  display: flex !important;
}

/* Override any inline styles */
#variant-modal[style*="display: none"] {
  display: none !important;
}

#variant-modal.show[style*="display: none"] {
  display: flex !important;
}

#variant-modal .bg-white {
  position: relative !important;
  z-index: 10000 !important;
  max-height: 80vh !important;
  overflow-y: auto !important;
}

/* Ensure modal content is properly styled */
#variant-modal .bg-white * {
  box-sizing: border-box !important;
}

/* Override any conflicting button styles */
#variant-modal .btn {
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 0.5rem 1.5rem !important;
  font-weight: 500 !important;
  border-radius: 0.375rem !important;
  transition: all 0.2s !important;
  text-decoration: none !important;
  border: none !important;
  cursor: pointer !important;
}

#variant-modal .btn-primary {
  background-color: #3b82f6 !important;
  color: white !important;
}

#variant-modal .btn-primary:hover {
  background-color: #2563eb !important;
}

/* Responsive design */
@media (max-width: 768px) {
  .p-6 { padding: var(--spacing-4); }
  .text-3xl { font-size: 1.5rem; }
  .max-w-6xl { max-width: 100%; }
  .card-header { padding: var(--spacing-4); }
  .card-content { padding: var(--spacing-4); }
  .table { font-size: 0.875rem; }
  .table th,
  .table td { padding: var(--spacing-2) var(--spacing-1); }
}
</style>

<div class="cart-builder-container w-full max-w-6xl mx-auto p-6 space-y-8 text-size-{{ block.settings.text_size | default: 'small' }}">
  <!-- Header Section -->
  <div class="text-center space-y-4">
    <h1 class="text-3xl font-semibold text-foreground">
      Bulky Cart Builder (Beta)
    </h1>
    <p class="text-muted-foreground max-w-2xl mx-auto">
      Search and add multiple products to your shopping list efficiently. 
      Perfect for bulk orders and managing large product selections with ease.
    </p>
    
    <!-- Instructions for First-Time Users -->
    <div class="max-w-4xl mx-auto" style="background-color: transparent !important; margin-bottom: 20px;">
      <div class="border-b border-black" style="background-color: transparent !important;">
        <button class="w-full p-4 text-left flex items-center justify-between transition-colors" onclick="toggleInstructions()" style="background-color: transparent !important; border: none; outline: none;">
          <h2 class="text-lg font-semibold text-foreground">Get Started</h2>
          <svg id="instructions-icon" class="w-4 h-4 text-muted-foreground transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 9l6 6 6-6"></path>
          </svg>
        </button>
        
        <div id="instructions-content" class="hidden p-6 space-y-6 text-left">
          <!-- Step 1 -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">1) Find your products</h3>
            <p class="text-sm text-muted-foreground">Use the search box to look up items by name or SKU. If a product has options (size, color), click “Show Variants” to see them. Items that are out of stock will be clearly marked and cannot be added.</p>
            <div class="rounded border p-3 text-xs text-muted-foreground">[Image Placeholder: Searching products and opening variants]</div>
          </div>

          <!-- Step 2 -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">2) Add to your list</h3>
            <p class="text-sm text-muted-foreground">Click “Add” to place an item into your Shopping List. For products with variants, add the specific variant you need. You can add several items in a row; the results list stays open until you click outside it.</p>
            <div class="rounded border p-3 text-xs text-muted-foreground">[Image Placeholder: Adding items to the shopping list]</div>
          </div>

          <!-- Step 3 -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">3) Review and adjust</h3>
            <p class="text-sm text-muted-foreground">In the Shopping List, use the plus and minus buttons to change quantities or click the trash icon to remove an item. The line Total and overall Total update automatically.</p>
            <div class="rounded border p-3 text-xs text-muted-foreground">[Image Placeholder: Adjusting quantities and seeing totals]</div>
          </div>

          <!-- Step 4 -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">4) Importing from CSV (optional)</h3>
            <p class="text-sm text-muted-foreground">Click “Import CSV” to add many items at once. Your file should include columns: Product Title, Variant, SKU, Price, Quantity. For single‑variant products, you may leave Variant blank.</p>
            <ul class="text-sm text-muted-foreground ml-4 mt-1 space-y-1">
              <li>• <strong>Tip</strong>: Including the SKU gives the most accurate match.</li>
              <li>• If something doesn’t match, you’ll see a note. You can add it manually from search.</li>
            </ul>
            <div class="rounded border p-3 text-xs text-muted-foreground">[Image Placeholder: Example CSV and import button]</div>
          </div>

          <!-- Step 5 -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">5) Add to Shopify cart</h3>
            <p class="text-sm text-muted-foreground">When you’re ready, click “Add to Cart”. We’ll quickly check stock for each item. If something is out of stock, we’ll highlight it for you to remove before continuing.</p>
            <div class="rounded border p-3 text-xs text-muted-foreground">[Image Placeholder: Add to Cart and out-of-stock highlight]</div>
          </div>

          <!-- Helpful notes -->
          <div class="space-y-2">
            <h3 class="font-medium text-foreground">Helpful notes</h3>
            <ul class="text-sm text-muted-foreground ml-4 space-y-1">
              <li>• You can export your list as a CSV for record‑keeping.</li>
              <li>• The list stays until you clear it or refresh the page.</li>
              <li>• For single‑variant products, Variant can be left blank in CSV (no need to type “Default Title”).</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Search Section -->
  <div class="relative">
    <div class="relative">
      {% comment %} <svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
      </svg> {% endcomment %}
      <input 
        type="text" 
        id="search-input"
        placeholder="Search products by name, SKU, or variant..." 
        class="input pl-10 pr-4 py-3 w-full text-base"
      />
    </div>
    {% comment %} <div class="mt-2">
      <button class="btn btn-outline btn-sm" onclick="testAPIs()">Test APIs</button>
      <button class="btn btn-outline btn-sm" onclick="testCart()">Test Cart</button>
      <button class="btn btn-outline btn-sm" onclick="debugProducts()">Debug Products</button>
    </div> {% endcomment %}
    
    <!-- Search Results -->
    <div id="search-results" class="card absolute top-full left-0 right-0 mt-2 z-50 max-h-96 overflow-y-auto" style="display: none;">
      <div class="p-2" id="results-container">
        <!-- Results will be populated here -->
      </div>
    </div>
    
    <!-- Loading Spinner -->
    <div id="search-loader" class="card absolute top-full left-0 right-0 mt-2 z-50" style="display: none;">
      <div class="p-4 text-center">
        <div class="inline-flex items-center gap-2">
          <div class="animate-spin rounded-full h-4 w-4 border-2 border-primary border-t-transparent"></div>
          <span class="text-sm text-muted-foreground">Searching products...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Shopping List Section -->
  <div class="card">
    <div class="card-header">
      <div class="flex items-center justify-between">
        <h2 class="card-title">Shopping List</h2>
        <div class="flex items-center gap-4">
          <div class="flex items-center gap-2">
            {% comment %} <button class="btn btn-outline btn-sm" onclick="downloadTemplate()">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              Download Template
            </button> {% endcomment %}
            <button class="btn btn-outline btn-sm" onclick="importCSV()">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
              </svg>
              Import CSV
            </button>
            <button class="btn btn-outline btn-sm" onclick="exportCSV()" id="export-btn" disabled>
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
              </svg>
              Export CSV
            </button>
            <button class="btn btn-outline btn-sm text-destructive hover:text-destructive hover:bg-destructive/10" onclick="clearAll()" id="clear-btn" disabled>
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
              </svg>
              Clear All
            </button>
            {% comment %} <button class="btn btn-outline btn-sm" onclick="clearProductCache()" title="Clear search cache">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
              </svg>
              Clear Cache
            </button> {% endcomment %}
          </div>
          <div class="flex items-center gap-4 text-sm text-muted-foreground">
            <span id="total-items">0 items</span>
            <span class="font-medium text-foreground">
              Total: $<span id="total-value">0.00</span>
            </span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="card-content">
      <!-- Empty State -->
      <div id="empty-state" class="text-center py-12 text-muted-foreground">
        <div class="mb-4">
          <div class="w-16 h-16 mx-auto bg-muted rounded-full flex items-center justify-center">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
            </svg>
          </div>
        </div>
        <p class="text-lg mb-2">Your shopping list is empty</p>
        <p class="text-sm mb-4">Search for products above to start building your list</p>
        <p class="text-xs text-muted-foreground">
          Or import a CSV file with columns: Product Title, Variant, SKU, Price, Quantity
        </p>
      </div>

      <!-- Shopping List Table -->
      <div id="shopping-list" style="display: none;">
        <div class="overflow-x-auto">
          <table class="table">
          <thead>
              <tr class="border-b">
                <th class="text-left py-3 px-2 font-medium text-muted-foreground">Product Title</th>
                <th class="text-left py-3 px-2 font-medium text-muted-foreground">Variant</th>
                <th class="text-left py-3 px-2 font-medium text-muted-foreground">SKU</th>
                <th class="text-right py-3 px-2 font-medium text-muted-foreground">Price</th>
                <th class="text-center py-3 px-2 font-medium text-muted-foreground">Qty</th>
                <th class="text-right py-3 px-2 font-medium text-muted-foreground">Total</th>
                <th class="text-center py-3 px-2 font-medium text-muted-foreground">Actions</th>
            </tr>
          </thead>
            <tbody id="cart-items">
              <!-- Cart items will be populated here -->
          </tbody>
        </table>
        </div>
        
        <!-- Summary Footer -->
        <div class="flex justify-between items-center pt-4 mt-4 border-t">
          <div class="text-sm text-muted-foreground">
            <span id="summary-items">0</span> items in your shopping list
          </div>
          <div class="flex items-center gap-4">
            <button class="btn btn-primary" onclick="addToShopifyCart()" id="add-to-cart-btn" disabled>
              {% comment %} <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 3h2l.4 2M7 13h10l4-8H5.4m0 0L7 13m0 0l-2.5 5M7 13l2.5 5m6-5v6a2 2 0 01-2 2H9a2 2 0 01-2-2v-6m8 0V9a2 2 0 00-2-2H9a2 2 0 00-2 2v4.01"></path>
              </svg> {% endcomment %}
              Add to Cart
            </button>
            <div class="font-semibold text-lg">
              Total: $<span id="summary-total">0.00</span>
            </div>
          </div>
        </div>
        </div>
      </div>
    </div>
  </div>

<!-- Hidden file input for CSV import -->
<input type="file" id="csv-input" accept=".csv" style="display: none;" onchange="handleFileImport(event)">



  <script>
// Get the excluded tag setting from the block configuration
const excludedTag = {{ block.settings.excluded_tag | json }};
console.log('Excluded tag setting:', excludedTag);

// Customer access control setup
// Capture the logged-in customer's tags from Liquid into JS
const customerTags = {{ customer.tags | json }} || [];
console.log('Customer tags:', customerTags);

// Product tags that gate visibility. If a product has any of these tags,
// only customers who also have at least one of the same tags can see it.
const accessGateTags = ['VIP-PMA', 'VIP-CMA', 'RSB'];

function normalizeProductTags(tags) {
  if (!tags) return [];
  if (Array.isArray(tags)) return tags.map(t => String(t).trim()).filter(Boolean);
  // Shopify often returns comma-separated string
  return String(tags).split(',').map(t => t.trim()).filter(Boolean);
}

function isProductVisibleToCustomer(product) {
  try {
    const productTags = normalizeProductTags(product.tags);
    const gatedOnProduct = productTags.filter(t => accessGateTags.includes(t));
    // If no gated tags are present, product is visible to everyone
    if (gatedOnProduct.length === 0) return true;
    // Otherwise, require customer to have at least one of the gated tags present on the product
    return gatedOnProduct.some(tag => customerTags.includes(tag));
  } catch (e) {
    console.warn('Access check failed, default allow:', e);
    return true;
  }
}

// Shopify product data - will be populated from your store
let shopifyProducts = [];
let productCache = new Map(); // Cache for search results
let lastSearchTime = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache

// Function to load ALL products from Shopify (for CSV imports)
async function loadAllShopifyProducts() {
  try {
    console.log('Loading all products for CSV import...');
    
    // Shopify API has a maximum limit of 250 products per request
    // We'll fetch in batches to get all products
    let allProducts = [];
    let page = 1;
    const limit = 250; // Maximum allowed by Shopify
    
    while (true) {
      const response = await fetch(`/products.json?limit=${limit}&page=${page}`);
      if (!response.ok) {
        console.log('Failed to fetch products page', page);
        break;
      }
      
      const data = await response.json();
      const pageProducts = data.products;
      
      if (pageProducts.length === 0) {
        console.log('No more products to fetch');
        break;
      }
      
      console.log(`Fetched ${pageProducts.length} products from page ${page}`);
      allProducts = allProducts.concat(pageProducts);
      
      // If we got fewer products than the limit, we've reached the end
      if (pageProducts.length < limit) {
        break;
      }
      
      page++;
      
      // Safety check to prevent infinite loops
      if (page > 10) {
        console.log('Reached maximum page limit, stopping');
        break;
      }
    }
    
    console.log(`Total products fetched: ${allProducts.length}`);
    
    // Process all products and their variants
    const processedProducts = allProducts.flatMap(product => 
      product.variants.map(variant => ({
        id: product.id.toString(),
        title: product.title,
        variant: variant.title,
        sku: variant.sku || '',
        price: parseFloat(variant.price),
        variantId: variant.id.toString(),
        handle: product.handle
      }))
    );
    
    shopifyProducts = processedProducts;
    console.log(`Total variants processed: ${shopifyProducts.length}`);
    
    return shopifyProducts;
    
  } catch (error) {
    console.error('Error loading Shopify products:', error);
    return [];
  }
}

// Lazy loading function - only loads products when import is attempted
async function ensureProductsLoaded() {
  if (shopifyProducts.length === 0) {
    console.log('No products loaded yet, loading all products for import...');
    await loadAllShopifyProducts();
  }
  return shopifyProducts;
}

// Function to load products from Shopify
async function loadShopifyProducts() {
  try {
    // Method 1: Try to get products from the current page
    let products = [];
    
    // Look for product data in various formats
    const productElements = document.querySelectorAll('[data-product-id], .product-item, .product-card, .product, [class*="product"]');
    
    console.log('Found product elements:', productElements.length);
    
    if (productElements.length > 0) {
      productElements.forEach(element => {
        const productId = element.getAttribute('data-product-id') || element.getAttribute('data-product-id');
        const productTitle = element.querySelector('[data-product-title], .product-title, h3, h4')?.textContent?.trim() || '';
        const productHandle = element.getAttribute('data-product-handle') || '';
        
        // Get variants from the page
        const variantElements = element.querySelectorAll('[data-variant-id], .variant-option');
        if (variantElements.length > 0) {
          variantElements.forEach(variantEl => {
            const variantId = variantEl.getAttribute('data-variant-id') || variantEl.getAttribute('data-variant-id');
            const variantTitle = variantEl.getAttribute('data-variant-title') || variantEl.textContent?.trim() || '';
            const variantSku = variantEl.getAttribute('data-variant-sku') || '';
            const variantPrice = parseFloat(variantEl.getAttribute('data-variant-price') || '0');
            
            if (productId && variantId) {
              products.push({
                id: productId,
                title: productTitle,
                variant: variantTitle,
                sku: variantSku,
                price: variantPrice,
                variantId: variantId,
                handle: productHandle
              });
            }
          });
        } else {
          // If no variants found, treat the product as a single variant
          const variantId = element.getAttribute('data-variant-id') || productId;
          const variantTitle = element.getAttribute('data-variant-title') || '';
          const variantSku = element.getAttribute('data-variant-sku') || '';
          const variantPrice = parseFloat(element.getAttribute('data-variant-price') || '0');
          
          if (productId) {
            products.push({
              id: productId,
              title: productTitle,
              variant: variantTitle,
              sku: variantSku,
              price: variantPrice,
              variantId: variantId,
              handle: productHandle
            });
          }
        }
      });
    }
    
    // Method 2: If no products found on page, try to fetch from Shopify API
    if (products.length === 0) {
      try {
        // Try to fetch products from Shopify's product API
        const response = await fetch('/products.json?limit=50');
        if (response.ok) {
          const data = await response.json();
          products = data.products.flatMap(product => 
            product.variants.map(variant => ({
              id: product.id.toString(),
              title: product.title,
              variant: variant.title,
              sku: variant.sku || '',
              price: parseFloat(variant.price),
              variantId: variant.id.toString(),
              handle: product.handle
            }))
          );
        }
      } catch (apiError) {
        console.log('Could not fetch from Shopify API:', apiError);
      }
    }
    
    shopifyProducts = products;
    console.log('Loaded Shopify products:', shopifyProducts.length);
    console.log('Products loaded:', shopifyProducts);
    
    // If still no products, show a message
    if (shopifyProducts.length === 0) {
      console.log('No products found on page. Products will be loaded via predictive search API when searching.');
    }
  } catch (error) {
    console.error('Error loading Shopify products:', error);
  }
}

let cartItems = [];
let searchResults = [];

// Search functionality with Shopify Predictive Search API
let searchTimeout;

document.getElementById('search-input').addEventListener('input', function(e) {
  const query = e.target.value.trim();
  
  // Clear previous timeout
  if (searchTimeout) {
    clearTimeout(searchTimeout);
  }
  
  if (query === '') {
    hideSearchResults();
    return;
  }

  console.log('Search input:', query);
  
  // Debounce search to avoid too many API calls
  searchTimeout = setTimeout(() => {
    showSearchLoader();
    performPredictiveSearch(query);
  }, 300);
});

async function performPredictiveSearch(query) {
  try {
    console.log('Searching for:', query);
    
    // Check cache first
    const cacheKey = query.toLowerCase().trim();
    const now = Date.now();
    
    if (productCache.has(cacheKey) && (now - lastSearchTime) < CACHE_DURATION) {
      console.log('Using cached results for:', query);
      const cachedResults = productCache.get(cacheKey);
      hideSearchLoader();
      showSearchResults(cachedResults);
      return;
    }
    
    let products = [];
    
    // Use Shopify's Predictive Search API
    try {
      console.log('Using Shopify Predictive Search API...');
      
      // Check if this looks like a SKU search (numeric or alphanumeric pattern)
      const isSkuSearch = /^[0-9A-Za-z\-_]+$/.test(query.trim()) && query.trim().length >= 3;
      console.log('Is SKU search?', isSkuSearch, 'Query:', query);
      
      // Build search URL with appropriate fields
      let searchUrl;
      if (isSkuSearch) {
        // For SKU searches, include variants.sku in the searchable fields
        searchUrl = `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=product&resources[limit]=20&resources[options][fields]=title,product_type,variants.title,variants.sku,vendor`;
        console.log('SKU search URL:', searchUrl);
      } else {
        // For regular searches, use default fields
        searchUrl = `/search/suggest.json?q=${encodeURIComponent(query)}&resources[type]=product&resources[limit]=20`;
        console.log('Regular search URL:', searchUrl);
      }
      
      // First, get search suggestions from Shopify's predictive search
      const searchResponse = await fetch(searchUrl);
      
      if (searchResponse.ok) {
        const searchData = await searchResponse.json();
        console.log('Predictive search results:', searchData);
        
        if (searchData.resources && searchData.resources.results && searchData.resources.results.products) {
          const suggestedProducts = searchData.resources.results.products;
          console.log('Suggested products:', suggestedProducts.length);
          
          // Get full product details for each suggested product
          const productPromises = suggestedProducts.map(async (suggestedProduct) => {
            try {
              const productResponse = await fetch(`/products/${suggestedProduct.handle}.json`);
              if (productResponse.ok) {
                const productData = await productResponse.json();
                return productData.product;
              }
            } catch (error) {
              console.log('Failed to fetch product details for:', suggestedProduct.handle);
            }
            return null;
          });
          
          const productDetails = await Promise.all(productPromises);
          const validProducts = productDetails.filter(p => p !== null);
          
          console.log('Valid products with details:', validProducts.length);
          
          // Filter out products with excluded tag (if set) and apply customer access control
          const filteredProducts = (excludedTag ? validProducts.filter(product => {
            const productTags = normalizeProductTags(product.tags);
            const hasExcludedTag = productTags.includes(excludedTag);
            if (hasExcludedTag) {
              console.log(`Excluding product with ${excludedTag} tag: ${product.title}`);
            }
            return !hasExcludedTag;
          }) : validProducts).filter(p => {
            const visible = isProductVisibleToCustomer(p);
            if (!visible) {
              console.log('Hiding gated product for this customer:', p.title, p.tags);
            }
            return visible;
          });
          
          console.log('Products after excluded tag filter:', filteredProducts.length);
          
          // Process products and their variants
          const processedProducts = [];
          
          console.log('Processing filtered products:', filteredProducts.length);
          
          // Process products with async/await properly
          for (let i = 0; i < filteredProducts.length; i++) {
            const product = filteredProducts[i];
            console.log(`Product ${i + 1}: ${product.title}`);
            console.log(`- Available: ${product.available}`);
            console.log(`- Variants: ${product.variants.length}`);
            
            // Since predictive search returns products with empty variants array,
            // we need to fetch full product details to get actual variants
            console.log(`✓ Processing product ${product.title} from predictive search`);
            
            try {
              const productResponse = await fetch(`/products/${product.handle}.json`);
              if (productResponse.ok) {
                const productData = await productResponse.json();
                const fullProduct = productData.product;
                
                console.log(`  Full product variants: ${fullProduct.variants.length}`);
                
                // Only add the product once, not each variant separately
                // Use the first variant for display purposes, but store all variants for the modal
                const firstVariant = fullProduct.variants[0];
                
                console.log(`  Using first variant: ${firstVariant.title} (SKU: ${firstVariant.sku || 'N/A'}) - Available: ${firstVariant.available}`);
                
                // Calculate relevance score based on the best match across all variants
                let bestScore = 0;
                const searchLower = query.toLowerCase();
                const titleLower = product.title.toLowerCase();
                
                // Check all variants for the best match
                fullProduct.variants.forEach(variant => {
                  const skuLower = (variant.sku || '').toLowerCase();
                  const variantTitleLower = variant.title.toLowerCase();
                  let variantScore = 0;
                  
                  // SKU exact match gets highest priority
                  if (skuLower === searchLower) {
                    variantScore += 3000;
                  }
                  // SKU contains search query
                  else if (skuLower.includes(searchLower)) {
                    variantScore += 1500;
                  }
                  
                  // Variant title match
                  if (variantTitleLower.includes(searchLower)) {
                    variantScore += 300;
                  }
                  
                  bestScore = Math.max(bestScore, variantScore);
                });
                
                // Title-based scoring
                if (titleLower === searchLower) {
                  bestScore += 2000;
                } else if (titleLower.startsWith(searchLower)) {
                  bestScore += 1000;
                } else if (titleLower.includes(searchLower)) {
                  bestScore += 500;
                }
                
                console.log(`  Best score: ${bestScore}`);
                
                // Store the product with all its variants for modal use
                processedProducts.push({
                  id: product.id.toString(),
                  title: product.title,
                  variant: firstVariant.title,
                  sku: firstVariant.sku || '',
                  price: parseFloat(firstVariant.price),
                  variantId: firstVariant.id.toString(),
                  handle: product.handle,
                  image: product.featured_image || product.image,
                  available: firstVariant.available,
                  score: bestScore,
                  hasMultipleVariants: fullProduct.variants.length > 1,
                  allVariants: fullProduct.variants // Store all variants for modal
                });
              }
            } catch (error) {
              console.log(`Failed to get variant data for ${product.title}:`, error);
            }
          }
          
          // Sort by relevance score (highest first)
          processedProducts.sort((a, b) => b.score - a.score);
          
          console.log('Processed products before score removal:', processedProducts.length);
          console.log('Sample processed products:', processedProducts.slice(0, 3));
          
          // Remove score from final results
          products = processedProducts.map(product => {
            const { score, ...productWithoutScore } = product;
            return productWithoutScore;
          });
          
          console.log('Final processed products:', products.length);
          console.log('Sample final products:', products.slice(0, 3));
        }
      } else {
        console.log('Predictive search failed, falling back to direct product search...');
        
        // Fallback: direct product search for SKUs
        if (query.length <= 10) { // Likely a SKU
          try {
            const fallbackResponse = await fetch(`/products.json?limit=250`);
            if (fallbackResponse.ok) {
              const fallbackData = await fallbackResponse.json();
              const allProducts = fallbackData.products.filter(p => p.published_at && p.status === 'active');
              
              // Filter out products with excluded tag (if set) and apply customer access control
              const filteredProducts = (excludedTag ? allProducts.filter(product => {
                const productTags = normalizeProductTags(product.tags);
                const hasExcludedTag = productTags.includes(excludedTag);
                if (hasExcludedTag) {
                  console.log(`Excluding product with ${excludedTag} tag (fallback): ${product.title}`);
                }
                return !hasExcludedTag;
              }) : allProducts).filter(p => isProductVisibleToCustomer(p));
              
              // Search for exact SKU matches
              const skuMatches = [];
              filteredProducts.forEach(product => {
                product.variants.forEach(variant => {
                  if (variant.sku && variant.sku.toLowerCase() === query.toLowerCase()) {
                    skuMatches.push({
                      id: product.id.toString(),
                      title: product.title,
                      variant: variant.title,
                      sku: variant.sku || '',
                      price: parseFloat(variant.price),
                      variantId: variant.id.toString(),
                      handle: product.handle,
                      image: product.featured_image || product.image,
                      available: variant.available,
                      hasMultipleVariants: product.variants.length > 1,
                      allVariants: product.variants // Add all variants for modal use
                    });
                  }
                });
              });
              
              products = skuMatches;
              console.log('SKU fallback matches:', products.length);
            }
          } catch (fallbackError) {
            console.log('Fallback search failed:', fallbackError);
          }
        }
      }
    } catch (searchError) {
      console.log('Search failed:', searchError);
    }
    
    // If no results from predictive search and query looks like a SKU, try direct SKU search
    if (products.length === 0 && query.length <= 10 && /^\d+$/.test(query)) {
      console.log('No predictive results, trying direct SKU search...');
      try {
        const skuResponse = await fetch(`/products.json?limit=250`);
        if (skuResponse.ok) {
          const skuData = await skuResponse.json();
          const allProducts = skuData.products.filter(p => p.published_at && p.status === 'active');
          
          // Filter out products with excluded tag (if set) and apply customer access control
          const filteredProducts = (excludedTag ? allProducts.filter(product => {
            const productTags = normalizeProductTags(product.tags);
            const hasExcludedTag = productTags.includes(excludedTag);
            if (hasExcludedTag) {
              console.log(`Excluding product with ${excludedTag} tag (direct SKU): ${product.title}`);
            }
            return !hasExcludedTag;
          }) : allProducts).filter(p => isProductVisibleToCustomer(p));
          
          // Search for exact SKU matches
          const skuMatches = [];
          filteredProducts.forEach(product => {
            product.variants.forEach(variant => {
              if (variant.sku && variant.sku.toLowerCase() === query.toLowerCase()) {
                skuMatches.push({
                  id: product.id.toString(),
                  title: product.title,
                  variant: variant.title,
                  sku: variant.sku || '',
                  price: parseFloat(variant.price),
                  variantId: variant.id.toString(),
                  handle: product.handle,
                  image: product.featured_image || product.image,
                  available: variant.available,
                  hasMultipleVariants: product.variants.length > 1,
                  allVariants: product.variants // Add all variants for modal use
                });
              }
            });
          });
          
          products = skuMatches;
          console.log('Direct SKU search matches:', products.length);
        }
      } catch (skuError) {
        console.log('Direct SKU search failed:', skuError);
      }
    }
    
    console.log('Final search results:', products);
    
    // Cache the results
    productCache.set(cacheKey, products);
    lastSearchTime = now;
    
    hideSearchLoader();
    showSearchResults(products);
    
  } catch (error) {
    console.error('Search error:', error);
    hideSearchLoader();
    showSearchResults([]);
  }
}

function showSearchResults(products) {
  searchResults = products;
  console.log('=== SHOW SEARCH RESULTS ===');
  console.log('Products to show:', products);
  console.log('Search results set to:', searchResults);
  console.log('Search results length:', searchResults.length);
  
  const container = document.getElementById('results-container');
  const resultsDiv = document.getElementById('search-results');
  
  console.log('Container element:', container);
  console.log('Results div element:', resultsDiv);
  
  if (products.length === 0) {
    container.innerHTML = `
      <div class="p-4 text-center text-muted-foreground">
        No products found for "${document.getElementById('search-input').value}"
      </div>
    `;
  } else {
    container.innerHTML = products.map(product => `
      <div class="border-b border-gray-200 last:border-b-0">
        <div class="flex items-center justify-between p-3 hover:bg-accent rounded-lg transition-colors">
          <div class="flex-1 space-y-1">
            <div class="flex items-center gap-2">
              <span class="font-medium">${product.title}</span>
              ${!product.hasMultipleVariants && product.variant !== 'Default Title' ? `<span class="badge badge-secondary text-xs">${product.variant}</span>` : ''}
               ${(!product.hasMultipleVariants && (product.available === false || product.available === 'false' || product.available === 0))
                  ? `<span class=\"badge badge-outline text-xs\">Out of stock</span>`
                  : ''}
            </div>
            <div class="flex items-center gap-4 text-sm text-muted-foreground">
              <span>SKU: ${product.hasMultipleVariants ? getParentSku(product.sku) : (product.sku || 'N/A')}</span>
              <span class="font-medium text-foreground">$${product.price.toFixed(2)}</span>
            </div>
          </div>
          
          <div class="flex items-center gap-2">
            ${product.hasMultipleVariants ? '' : `
              <div class="flex items-center border rounded" style="width: 52px; height: 24px;">
                <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px; ${((product.available === false || product.available === 'false' || product.available === 0) ? 'opacity: 0.5; cursor: not-allowed;' : '')}" ${((product.available === false || product.available === 'false' || product.available === 0) ? 'disabled' : '')} onclick="updateQuantity('${product.variantId}', -1)">
                  -
                </button>
                <span style="width: 20px; height: 24px; border-left: 1px solid #ccc; border-right: 1px solid #ccc; text-align: center; font-size: 12px; line-height: 24px;" id="qty-${product.variantId}">1</span>
                <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px; ${((product.available === false || product.available === 'false' || product.available === 0) ? 'opacity: 0.5; cursor: not-allowed;' : '')}" ${((product.available === false || product.available === 'false' || product.available === 0) ? 'disabled' : '')} onclick="updateQuantity('${product.variantId}', 1)">
                  +
                </button>
              </div>
            `}
            <button id="toggle-${product.handle}" class="btn btn-sm btn-primary" ${(
                (!product.hasMultipleVariants && (product.available === false || product.available === 'false' || product.available === 0))
              ? 'disabled style=\"opacity:0.5;cursor:not-allowed;\"' : '')} onclick="event.stopPropagation(); ${product.hasMultipleVariants ? 'toggleVariants(\'' + product.handle + '\')' : 'addToCartFromSearch(\'' + product.variantId + '\')'}">
              ${product.hasMultipleVariants ? `
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
              ` : `
                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                </svg>
              `}
              ${product.hasMultipleVariants
                ? 'Show Variants'
                : ((product.available === false || product.available === 'false' || product.available === 0) ? 'Out of stock' : 'Add')}
            </button>
          </div>
        </div>
                 ${product.hasMultipleVariants ? `
           <div id="variants-${product.handle}" style="display: none; background-color: #f7f7f7;" class="bg-gray-50 border-t border-gray-200">
             <!-- Variants will be loaded here when toggled -->
           </div>
         ` : ''}
      </div>
    `).join('');
  }
  
  console.log('Setting display to block');
  resultsDiv.style.display = 'block';
  console.log('Display style after setting:', resultsDiv.style.display);
  console.log('Container HTML length:', container.innerHTML.length);
  
  // Debug positioning
  console.log('Results div position:', resultsDiv.getBoundingClientRect());
  console.log('Results div z-index:', window.getComputedStyle(resultsDiv).zIndex);
}

function showSearchLoader() {
  document.getElementById('search-loader').style.display = 'block';
  document.getElementById('search-results').style.display = 'none';
}

function hideSearchLoader() {
  document.getElementById('search-loader').style.display = 'none';
}

function hideSearchResults() {
  document.getElementById('search-results').style.display = 'none';
  document.getElementById('search-loader').style.display = 'none';
}

// Quantity management for search results
const searchQuantities = {};

function updateQuantity(variantId, change) {
  const currentQty = searchQuantities[variantId] || 1;
  const newQty = Math.max(1, currentQty + change);
  searchQuantities[variantId] = newQty;
  document.getElementById(`qty-${variantId}`).textContent = newQty;
}

function addToCartFromSearch(variantId) {
  console.log('=== ADD TO CART DEBUG ===');
  console.log('VariantId:', variantId);
  console.log('Search results length:', searchResults.length);
  console.log('Search results:', searchResults);
  console.log('Cart items before:', cartItems);
  
  // Find the product in search results
  const product = searchResults.find(p => p.variantId === variantId);
  const quantity = searchQuantities[variantId] || 1;
  
  console.log('Found product:', product);
  console.log('Quantity to add:', quantity);
  
  if (product) {
    // Add to shopping list
    console.log('Calling addToCart with:', product, quantity);
    addToCart(product, quantity);
    
    // Reset quantity and hide search results
    searchQuantities[variantId] = 1;
    const qtyElement = document.getElementById(`qty-${variantId}`);
    if (qtyElement) {
      qtyElement.textContent = '1';
    }
    
    // Keep results open; do not hide on add. Optional: clear input but retain list.
    // document.getElementById('search-input').value = '';
    
    // Show success feedback
    showAddSuccess(product.title, quantity);
    
    console.log('Cart items after:', cartItems);
  } else {
    console.error('Product not found for variantId:', variantId);
    console.error('Available variantIds:', searchResults.map(p => p.variantId));
    console.error('Search results:', searchResults);
    alert('Product not found. Please try searching again.');
  }
}

function showAddSuccess(productTitle, quantity) {
  // Create a temporary success message
  const successDiv = document.createElement('div');
  successDiv.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50';
  successDiv.innerHTML = `
    <div class="flex items-center gap-2">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
      </svg>
      <span>Added ${quantity}x ${productTitle} to shopping list</span>
    </div>
  `;
  
  document.body.appendChild(successDiv);
  
  // Remove after 3 seconds
  setTimeout(() => {
    if (successDiv.parentNode) {
      successDiv.parentNode.removeChild(successDiv);
    }
  }, 3000);
}

// Cart management
function addToCart(product, quantity = 1) {
  console.log('=== ADD TO CART FUNCTION ===');
  console.log('Adding product:', product);
  console.log('Quantity:', quantity);
  console.log('Current cart items:', cartItems);
  
  const existingItem = cartItems.find(item => item.variantId === product.variantId);
  
  if (existingItem) {
    console.log('Found existing item, updating quantity');
    existingItem.quantity += quantity;
  } else {
    console.log('Adding new item to cart');
    cartItems.push({ ...product, quantity });
  }
  
  console.log('Cart items after add:', cartItems);
  updateCartDisplay();
}

function updateCartQuantity(variantId, quantity) {
  if (quantity <= 0) {
    removeFromCart(variantId);
    return;
  }
        
  const item = cartItems.find(item => item.variantId === variantId);
  if (item) {
    item.quantity = quantity;
    updateCartDisplay();
  }
}

function removeFromCart(variantId) {
  cartItems = cartItems.filter(item => item.variantId !== variantId);
  updateCartDisplay();
}

function updateCartDisplay() {
  console.log('=== UPDATE CART DISPLAY ===');
  console.log('Cart items:', cartItems);
  console.log('Cart items length:', cartItems.length);
  
  const totalItems = cartItems.reduce((sum, item) => sum + item.quantity, 0);
  const totalValue = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  
  console.log('Total items:', totalItems);
  console.log('Total value:', totalValue);
  
  // Update summary
  document.getElementById('total-items').textContent = `${totalItems} items`;
  document.getElementById('total-value').textContent = totalValue.toFixed(2);
  document.getElementById('summary-items').textContent = totalItems;
  document.getElementById('summary-total').textContent = totalValue.toFixed(2);
  
  // Update buttons
  const hasItems = cartItems.length > 0;
  document.getElementById('export-btn').disabled = !hasItems;
  document.getElementById('clear-btn').disabled = !hasItems;
  document.getElementById('add-to-cart-btn').disabled = !hasItems;
  
  // Show/hide empty state
  const emptyState = document.getElementById('empty-state');
  const shoppingList = document.getElementById('shopping-list');
  
  if (hasItems) {
    emptyState.style.display = 'none';
    shoppingList.style.display = 'block';
    
    // Update cart items table
    const tbody = document.getElementById('cart-items');
    tbody.innerHTML = cartItems.map(item => `
      <tr class="border-b hover:bg-accent/50 transition-colors">
        <td class="py-4 px-2">
          <div class="font-medium">${item.title}</div>
        </td>
        <td class="py-4 px-2">
          ${item.variant !== 'Default Title' ? `<span class="badge badge-outline text-xs">${item.variant}</span>` : ''}
        </td>
        <td class="py-4 px-2">
          <code class="text-xs bg-muted px-2 py-1 rounded">${item.sku}</code>
        </td>
        <td class="py-4 px-2 text-right font-medium">$${item.price.toFixed(2)}</td>
        <td class="py-4 px-2">
          <div class="flex items-center justify-center">
            <div class="flex items-center border rounded" style="width: 52px; height: 24px;">
              <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px;" onclick="updateCartQuantity('${item.variantId}', ${item.quantity - 1})" ${item.quantity <= 1 ? 'disabled' : ''}>
                -
              </button>
              <span style="width: 20px; height: 24px; border-left: 1px solid #ccc; border-right: 1px solid #ccc; text-align: center; font-size: 12px; line-height: 24px; display: flex; align-items: center; justify-content: center;">${item.quantity}</span>
              <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px;" onclick="updateCartQuantity('${item.variantId}', ${item.quantity + 1})">
                +
              </button>
            </div>
          </div>
        </td>
        <td class="py-4 px-2 text-right font-medium">$${(item.price * item.quantity).toFixed(2)}</td>
        <td class="py-4 px-2">
          <div class="flex justify-center">
            <button class="btn btn-ghost btn-sm text-destructive hover:text-destructive hover:bg-destructive/10" onclick="removeFromCart('${item.variantId}')">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
              </svg>
            </button>
          </div>
        </td>
      </tr>
    `).join('');
          } else {
    emptyState.style.display = 'block';
    shoppingList.style.display = 'none';
  }
}

// Utility functions
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    // You could add a toast notification here
    console.log('Variant ID copied to clipboard');
  });
}

function clearAll() {
  cartItems = [];
  updateCartDisplay();
}

      async function addToShopifyCart() {
        console.log('=== ADDING TO SHOPIFY CART ===');
        console.log('Cart items to add:', cartItems);
        
        if (cartItems.length === 0) {
          alert('No items to add to cart');
          return;
        }
        
        try {
          // 1) Pre-check stock availability for each line item using the .js product endpoint
          //    We'll gather any items that appear unavailable and highlight them instead of adding
          const unavailableRows = [];
          
          // Clear previous highlights
          document.querySelectorAll('#cart-items tr').forEach(tr => tr.classList.remove('oos-highlight'));
          
          for (const item of cartItems) {
            // Find the related product handle from search results cache if available
            let handle = '';
            let variantData = null;
            for (const product of searchResults || []) {
              if (product.allVariants) {
                const found = product.allVariants.find(v => v.id == item.variantId);
                if (found) {
                  handle = product.handle || '';
                  variantData = found;
                  break;
                }
              }
            }
            
            // If we don't have the handle, try to infer via window.location or skip to server add
            if (!handle) {
              // Cannot verify; proceed without blocking
              continue;
            }
            
            try {
              const resp = await fetch(`/products/${handle}.js`);
              if (!resp.ok) continue; // be permissive if fetch fails
              const prod = await resp.json();
              const variant = prod.variants.find(v => v.id == item.variantId);
              if (!variant) continue;
              
              const isAvailable = (typeof variant.available === 'boolean') ? variant.available
                : (typeof variant.available === 'string') ? (variant.available.toLowerCase() === 'true')
                : (typeof variant.inventory_quantity === 'number') ? (variant.inventory_quantity > 0 || variant.inventory_policy === 'continue')
                : (typeof variant.availableForSale === 'boolean') ? variant.availableForSale
                : (typeof variant.available_for_sale === 'boolean') ? variant.available_for_sale
                : true; // default permissive
              
              if (!isAvailable) {
                unavailableRows.push(item.variantId);
              }
            } catch (e) {
              console.warn('Stock pre-check failed for handle:', handle, e);
            }
          }
          
          if (unavailableRows.length > 0) {
            // Highlight rows and notify the user
            const tbody = document.getElementById('cart-items');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            for (const row of rows) {
              const idCellText = (row.querySelector('[data-variant-id]')?.getAttribute('data-variant-id')) || '';
              // Our rows don't include the id plainly; instead match by inline onclick content
              const minusBtn = row.querySelector('button[onclick^="updateCartQuantity("]');
              const match = minusBtn?.getAttribute('onclick')?.match(/updateCartQuantity\('\s*(\d+)'/);
              const rowVariantId = match ? match[1] : '';
              if (unavailableRows.includes(rowVariantId)) {
                row.classList.add('oos-highlight');
              }
            }
            alert('Some items are out of stock. Please remove the highlighted items before adding to cart.');
            return;
          }
          
          // 2) Proceed to add items one by one if all pass the availability check
          console.log('Adding items to Shopify cart...');
          
          // Add items one by one to ensure compatibility
          for (const item of cartItems) {
            const cartData = {
              items: [{
                id: parseInt(item.variantId),
                quantity: item.quantity
              }]
            };
            
            console.log(`Adding item: ${item.title} (${item.variant}) - Qty: ${item.quantity}`);
            
            const response = await fetch('/cart/add.js', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(cartData)
            });
            
            if (!response.ok) {
              const errorText = await response.text();
              console.error(`Failed to add item ${item.title}:`, errorText);
              throw new Error(`Failed to add ${item.title}: ${response.status}`);
            }
            
            const result = await response.json();
            console.log(`Successfully added ${item.title}:`, result);
          }
          
          // Show success message
          const totalItems = cartItems.reduce((sum, item) => sum + item.quantity, 0);
          const totalValue = cartItems.reduce((sum, item) => sum + (item.price * item.quantity), 0);
          
          alert(`Successfully added ${totalItems} items to your cart ($${totalValue.toFixed(2)})`);
          
          // Redirect to cart page
          window.location.href = '/cart';
          
        } catch (error) {
          console.error('Error adding to Shopify cart:', error);
          alert(`Error adding items to cart: ${error.message}. Please try again.`);
        }
      }

function exportCSV() {
        if (cartItems.length === 0) {
    alert('No items to export');
          return;
        }
        
  const headers = ['Product Title', 'Variant', 'SKU', 'Price', 'Quantity'];
        const csvContent = [
          headers.join(','),
    ...cartItems.map(item => [
            `"${item.title.replace(/"/g, '""')}"`,
      `"${(item.variant === 'Default Title' ? '' : item.variant).replace(/"/g, '""')}"`,
      `"${item.sku}"`,
      item.price.toString(),
      item.quantity.toString()
          ].join(','))
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
  link.setAttribute('download', `shopping-list-${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

// Updated import function with lazy loading
async function importCSV() {
  // Show loading message
  const loadingMessage = document.createElement('div');
  loadingMessage.id = 'import-loading';
  loadingMessage.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 20px;
    border-radius: 8px;
    z-index: 10000;
    font-size: 16px;
  `;
  loadingMessage.innerHTML = `
    <div style="text-align: center;">
      <div style="margin-bottom: 10px;">Loading product catalog...</div>
      <div style="font-size: 12px; opacity: 0.8;">This may take a moment for large stores</div>
    </div>
  `;
  document.body.appendChild(loadingMessage);
  
  try {
    // Load all products if not already loaded
    await ensureProductsLoaded();
    
    // Remove loading message
    if (loadingMessage.parentNode) {
      loadingMessage.parentNode.removeChild(loadingMessage);
    }
    
    // Trigger file input
    document.getElementById('csv-input').click();
    
  } catch (error) {
    console.error('Error loading products for import:', error);
    
    // Remove loading message
    if (loadingMessage.parentNode) {
      loadingMessage.parentNode.removeChild(loadingMessage);
    }
    
    alert('Error loading product catalog. Please try again.');
  }
}

function handleFileImport(event) {
  const file = event.target.files?.[0];
  if (!file) return;

  if (file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
    alert('Please select a CSV file');
    return;
  }

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const csv = e.target.result;
      const lines = csv.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        alert('CSV file appears to be empty or invalid');
        return;
      }

      const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
      const expectedHeaders = ['Product Title', 'Variant', 'SKU', 'Price', 'Quantity'];
      
      const hasAllHeaders = expectedHeaders.every(expected => 
        headers.some(header => header.toLowerCase() === expected.toLowerCase())
      );

      if (!hasAllHeaders) {
        alert('CSV file must contain columns: Product Title, Variant, SKU, Price, Quantity');
        return;
      }

      const importResults = {
        successful: [],
        failed: [],
        total: lines.length - 1
      };
      
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
        
        if (values.length !== headers.length) {
          console.warn(`Skipping row ${i + 1}: incorrect number of columns`);
          continue;
        }

        try {
          const getValueByHeader = (headerName) => {
            const index = headers.findIndex(h => h.toLowerCase() === headerName.toLowerCase());
            return index >= 0 ? values[index] : '';
          };

          const title = getValueByHeader('Product Title');
          let variant = getValueByHeader('Variant');
          // Treat blank variant as 'Default Title' to support non-variant products
          if (!variant) {
            variant = 'Default Title';
          }
          const sku = getValueByHeader('SKU');
          const price = parseFloat(getValueByHeader('Price'));
          const quantity = parseInt(getValueByHeader('Quantity'));

          if (!title || isNaN(price) || isNaN(quantity)) {
            console.warn(`Skipping row ${i + 1}: missing or invalid data`);
            continue;
          }

          // Use smart matching to find the product
          const matchedProduct = findProductByMultipleCriteria(title, variant, sku);
          
          if (matchedProduct) {
            importResults.successful.push({
              id: `imported-${i}`,
              title: matchedProduct.title,
              variant: matchedProduct.variant,
              sku: matchedProduct.sku,
              price: matchedProduct.price,
              quantity,
              variantId: matchedProduct.variantId
            });
          } else {
            importResults.failed.push({
              row: i + 1,
              title,
              variant,
              sku
            });
            console.warn(`No match found for row ${i + 1}: ${title} - ${variant}`);
          }
        } catch (error) {
          console.warn(`Error parsing row ${i + 1}:`, error);
        }
      }

      if (importResults.successful.length === 0) {
        alert('No valid items found in CSV file');
        return;
      }

      // Show import results to user
      showImportResults(importResults);
      
      // Add successful items to cart
      if (importResults.successful.length > 0) {
        cartItems = importResults.successful;
        updateCartDisplay();
      }
      
    } catch (error) {
      alert('Error reading CSV file');
      console.error('CSV import error:', error);
    }
  };

  reader.readAsText(file);
  event.target.value = ''; // Reset file input
}

// Click outside to hide search results
document.addEventListener('click', function(e) {
  const searchResults = document.getElementById('search-results');
  const searchInput = document.getElementById('search-input');
  
  if (!searchResults.contains(e.target) && !searchInput.contains(e.target)) {
    hideSearchResults();
  }
});

// Test function to debug API issues
async function testAPIs() {
  console.log('Testing APIs...');
  
  const apis = [
    '/search/suggest.json?q=test&resources[type]=product&resources[limit]=5',
    '/search?q=test&type=product&view=json',
    '/products.json?limit=5'
  ];
  
  for (let i = 0; i < apis.length; i++) {
    const api = apis[i];
    try {
      console.log(`Testing API ${i + 1}: ${api}`);
      const response = await fetch(api);
      console.log(`API ${i + 1} status:`, response.status);
      
      if (response.ok) {
        const data = await response.json();
        console.log(`API ${i + 1} data:`, data);
      } else {
        console.log(`API ${i + 1} failed:`, response.statusText);
      }
    } catch (error) {
      console.log(`API ${i + 1} error:`, error);
    }
  }
}

// Smart matching function for CSV imports
function findProductByMultipleCriteria(title, variant, sku) {
  console.log('=== SMART MATCHING ===');
  console.log('Looking for:', { title, variant, sku });
  console.log('Available products:', shopifyProducts.length);
  
  // Normalize input data
  const normalizedTitle = title.toLowerCase().trim();
  const normalizedVariant = variant.toLowerCase().trim();
  const normalizedSku = sku ? sku.toLowerCase().trim() : '';
  
  // First, try exact SKU match (most reliable)
  if (normalizedSku) {
    const skuMatch = shopifyProducts.find(p => 
      p.sku && p.sku.toLowerCase().trim() === normalizedSku
    );
    if (skuMatch) {
      console.log('✅ Found exact SKU match:', skuMatch);
      return skuMatch;
    }
  }
  
  // Second, try exact title + variant match
  const titleVariantMatch = shopifyProducts.find(p => 
    p.title.toLowerCase().trim() === normalizedTitle &&
    p.variant.toLowerCase().trim() === normalizedVariant
  );
  if (titleVariantMatch) {
    console.log('✅ Found exact title + variant match:', titleVariantMatch);
    return titleVariantMatch;
  }
  
  // Third, try partial title match with exact variant (but only if title is substantial)
  if (normalizedTitle.length >= 3) {
    const partialMatch = shopifyProducts.find(p => 
      p.title.toLowerCase().trim().includes(normalizedTitle) &&
      p.variant.toLowerCase().trim() === normalizedVariant
    );
    if (partialMatch) {
      console.log('✅ Found partial title match:', partialMatch);
      return partialMatch;
    }
  }
  
  // Fourth, try exact title with partial variant match (but only if variant is substantial)
  if (normalizedVariant.length >= 2) {
    const titlePartialVariantMatch = shopifyProducts.find(p => 
      p.title.toLowerCase().trim() === normalizedTitle &&
      p.variant.toLowerCase().trim().includes(normalizedVariant)
    );
    if (titlePartialVariantMatch) {
      console.log('✅ Found title with partial variant match:', titlePartialVariantMatch);
      return titlePartialVariantMatch;
    }
  }
  
  // Fifth, try fuzzy matching for similar titles
  const fuzzyMatch = shopifyProducts.find(p => {
    const productTitle = p.title.toLowerCase().trim();
    const productVariant = p.variant.toLowerCase().trim();
    
    // Check if titles are very similar (allowing for small differences)
    const titleSimilarity = calculateSimilarity(normalizedTitle, productTitle);
    const variantMatch = productVariant === normalizedVariant;
    
    return titleSimilarity > 0.8 && variantMatch;
  });
  
  if (fuzzyMatch) {
    console.log('✅ Found fuzzy title match:', fuzzyMatch);
    return fuzzyMatch;
  }
  
  console.log('❌ No match found for:', { title, variant, sku });
  return null;
}

// Helper function to calculate string similarity
function calculateSimilarity(str1, str2) {
  if (str1 === str2) return 1.0;
  if (str1.length === 0) return 0.0;
  if (str2.length === 0) return 0.0;
  
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;
  
  if (longer.length === 0) return 1.0;
  
  const editDistance = levenshteinDistance(longer, shorter);
  return (longer.length - editDistance) / longer.length;
}

// Levenshtein distance calculation
function levenshteinDistance(str1, str2) {
  const matrix = [];
  
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  
  return matrix[str2.length][str1.length];
}

// Show import results to user
function showImportResults(results) {
  let message = `Import completed!\n\n`;
  message += `✅ Successfully matched: ${results.successful.length} items\n`;
  
  if (results.failed.length > 0) {
    message += `❌ Failed to match: ${results.failed.length} items\n\n`;
    message += `Failed items:\n`;
    results.failed.forEach(item => {
      message += `• Row ${item.row}: ${item.title} - ${item.variant}`;
      if (item.sku) message += ` (SKU: ${item.sku})`;
      message += `\n`;
    });
    message += `\n💡 Tips for better matching:\n`;
    message += `• Include SKU numbers when possible\n`;
    message += `• Use exact product titles from your store\n`;
    message += `• Try searching manually first to see exact names\n`;
    message += `• Check for typos in product names or variants`;
  }
  
  alert(message);
}

// Download CSV template
function downloadTemplate() {
  const templateData = [
    ['Product Title', 'Variant', 'SKU', 'Price', 'Quantity'],
    ['Sample Product', 'Large', 'SAMPLE-001', '29.99', '2'],
    ['Another Product', 'Red', 'ANOTHER-002', '15.50', '1'],
    ['Basic Product', '', 'BASIC-003', '9.99', '3']
  ];
  
  const csvContent = templateData.map(row => 
    row.map(cell => `"${cell}"`).join(',')
  ).join('\n');
  
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', 'cart-builder-template.csv');
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Test function to debug cart functionality
function testCart() {
  console.log('=== TESTING CART ===');
  console.log('Cart items before test:', cartItems);
  
  const testProduct = {
    id: 'test-1',
    title: 'Test Product',
    variant: 'Test Variant',
    sku: 'TEST-001',
    price: 10.00,
    variantId: 'test-variant-1',
    handle: 'test-product',
    available: true
  };
  
  addToCart(testProduct, 1);
  
  console.log('Cart items after test:', cartItems);
}

// Toggle instructions dropdown
function toggleInstructions() {
  const content = document.getElementById('instructions-content');
  const icon = document.getElementById('instructions-icon');
  
  if (content.classList.contains('hidden')) {
    content.classList.remove('hidden');
    icon.style.transform = 'rotate(180deg)';
  } else {
    content.classList.add('hidden');
    icon.style.transform = 'rotate(0deg)';
  }
}

// Clear cache function
function clearProductCache() {
  productCache.clear();
  lastSearchTime = 0;
  console.log('Product cache cleared');
}

// Debug function to test product loading
async function debugProducts() {
  console.log('=== DEBUGGING PRODUCTS ===');
  
  try {
    // Test basic product fetch
    console.log('Testing basic product fetch...');
    const response = await fetch('/products.json?limit=5');
    console.log('Response status:', response.status);
    
    if (response.ok) {
      const data = await response.json();
      console.log('Raw products data:', data);
      console.log('Products count:', data.products?.length || 0);
      
      if (data.products && data.products.length > 0) {
        console.log('Sample product:', data.products[0]);
        console.log('Product status:', data.products[0].status);
        console.log('Product published_at:', data.products[0].published_at);
        console.log('Product variants:', data.products[0].variants?.length || 0);
      }
    } else {
      console.log('Failed to fetch products:', response.statusText);
    }
  } catch (error) {
    console.error('Debug error:', error);
  }
}

// Collapsible variant functions
function toggleVariants(productHandle) {
  console.log('Toggling variants for product:', productHandle);
  
  const variantContainer = document.getElementById(`variants-${productHandle}`);
  const toggleButton = document.getElementById(`toggle-${productHandle}`);
  
  if (variantContainer.style.display === 'none' || !variantContainer.style.display) {
    // Show variants
    loadAndShowVariants(productHandle);
    toggleButton.innerHTML = `
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
      </svg>
      Hide Variants
    `;
  } else {
    // Hide variants
    variantContainer.style.display = 'none';
    toggleButton.innerHTML = `
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
      </svg>
      Show Variants
    `;
  }
}

async function loadAndShowVariants(productHandle) {
  try {
    console.log('Loading variants for product:', productHandle);
    
    // Find the product in search results to get the stored variants
    const product = searchResults.find(p => p.handle === productHandle);
    
    // Decide whether we need to refetch to get inventory/availability fields
    let shouldRefetch = false;
    if (product && Array.isArray(product.allVariants) && product.allVariants.length > 0) {
      const sample = product.allVariants[0];
      const hasAvailabilityFields = (
        typeof sample.available === 'boolean' ||
        typeof sample.available === 'string' ||
        typeof sample.available === 'number' ||
        typeof sample.inventory_quantity === 'number' ||
        typeof sample.availableForSale === 'boolean' ||
        typeof sample.available_for_sale === 'boolean'
      );
      shouldRefetch = !hasAvailabilityFields;
    } else {
      shouldRefetch = true;
    }

    if (shouldRefetch) {
      console.log('Fetching product via .js endpoint to obtain availability fields...');
      const response = await fetch(`/products/${productHandle}.js`);
      if (response.ok) {
        const fullProduct = await response.json();
        // .js endpoint returns the product directly
        console.log('Fetched variants from .js:', fullProduct.variants?.length || 0);
        showVariantsInCollapsible(fullProduct.title, fullProduct.variants, productHandle);
      } else {
        console.warn('Failed to fetch .js endpoint, falling back to stored variants');
        if (product && product.allVariants) {
          showVariantsInCollapsible(product.title, product.allVariants, productHandle);
        } else {
          throw new Error('No variant data available');
        }
      }
    } else {
      console.log('Using stored variants with availability fields:', product.allVariants.length);
      showVariantsInCollapsible(product.title, product.allVariants, productHandle);
    }
  } catch (error) {
    console.error('Error loading variants:', error);
    alert('Error loading product variants. Please try again.');
  }
}

function showVariantsInCollapsible(productTitle, variants, productHandle) {
  console.log('Showing variants in collapsible for:', productTitle);
  console.log('Product handle:', productHandle);
  console.log('Total variants:', variants.length);
  
  const container = document.getElementById(`variants-${productHandle}`);
  console.log('Container element:', container);
  
  if (!container) {
    console.error('Container not found for product handle:', productHandle);
    return;
  }
  
  // Filter available variants
  const availableVariants = variants.filter(isVariantAvailable);
  
  console.log('Available variants:', availableVariants.length);
  
  if (variants.length > 0 && availableVariants.length === 0) {
    container.innerHTML = `
      <div class="text-center py-4 text-gray-600">
        <p>All variants are currently out of stock.</p>
      </div>
    `;
    container.style.display = 'block';
    console.log('Showing out of stock message');
    return;
  }
  
  const variantHTML = variants.map(variant => {
    console.log('Creating HTML for variant:', variant.title);
    const variantIsAvailable = isVariantAvailable(variant);
    return `
      <div class="border-t border-gray-200 py-3 px-3 bg-gray-50">
        <div class="flex items-center justify-between">
          <div class="flex-1 space-y-1">
            <div class="flex items-center gap-2">
              <span class="font-medium">${variant.title}</span>
              ${(!variantIsAvailable ? `<span class=\"badge badge-outline text-xs\">Out of stock</span>` : '')}
            </div>
            <div class="flex items-center gap-4 text-sm text-muted-foreground">
              <span>SKU: ${variant.sku || 'N/A'}</span>
              <span class="font-medium text-foreground">$${parseFloat(variant.price).toFixed(2)}</span>
            </div>
          </div>
          
          <div class="flex items-center gap-2">
            ${variantIsAvailable ? `
              <div class="flex items-center border rounded" style="width: 52px; height: 24px;">
                <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px;" onclick="updateVariantQuantity('${variant.id}', -1)">
                  -
                </button>
                <span style="width: 20px; height: 24px; border-left: 1px solid #ccc; border-right: 1px solid #ccc; text-align: center; font-size: 12px; line-height: 24px;" id="variant-qty-${variant.id}">1</span>
                <button style="width: 16px; height: 24px; border: none; background: transparent; cursor: pointer; font-size: 12px;" onclick="updateVariantQuantity('${variant.id}', 1)">
                  +
                </button>
              </div>
            ` : ''}
            <button class="btn btn-sm btn-primary" ${(!variantIsAvailable ? 'disabled style=\"opacity:0.5;cursor:not-allowed;\"' : '')} onclick="addVariantToCart('${variant.id}', '${productTitle}', '${variant.title}')">
              <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
              </svg>
              ${(!variantIsAvailable ? 'Out of stock' : 'Add')}
            </button>
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  console.log('Generated HTML length:', variantHTML.length);
  console.log('HTML preview:', variantHTML.substring(0, 200));
  
  container.innerHTML = variantHTML;
  container.style.display = 'block';
  
  console.log('Container display style after setting:', container.style.display);
  console.log('Container innerHTML length after setting:', container.innerHTML.length);
}

// Helper for checking variant availability, normalizing theme/API values
function isVariantAvailable(variant) {
  // Normalize variant availability across different data shapes
  if (!variant) return true; // be permissive; only disable when explicitly unavailable

  // Direct boolean
  if (typeof variant.available === 'boolean') {
    return variant.available;
  }

  // Numeric available (some themes encode as 0/1)
  if (typeof variant.available === 'number') {
    return variant.available > 0;
  }

  // String forms
  if (typeof variant.available === 'string') {
    const normalized = variant.available.toLowerCase();
    if (normalized === 'true') return true;
    if (normalized === 'false') return false;
    if (normalized === '0') return false;
  }

  // Inventory quantity (Shopify returns a number when present)
  if (typeof variant.inventory_quantity === 'number') {
    // If policy is continue, allow even at 0
    if (variant.inventory_policy === 'continue') return true;
    return variant.inventory_quantity > 0;
  }

  // Some storefront payloads expose availableForSale / available_for_sale
  if (typeof variant.availableForSale === 'boolean') {
    return variant.availableForSale;
  }
  if (typeof variant.available_for_sale === 'boolean') {
    return variant.available_for_sale;
  }

  // Fallback: assume available if we cannot determine
  return true;
}

function updateVariantQuantity(variantId, change) {
  const currentQty = variantQuantities[variantId] || 1;
  const newQty = Math.max(1, currentQty + change);
  variantQuantities[variantId] = newQty;
  document.getElementById(`variant-qty-${variantId}`).textContent = newQty;
}

// Store variant quantities
const variantQuantities = {};

// Helper function to extract parent SKU (before hyphen)
function getParentSku(sku) {
  if (!sku || sku === 'N/A') return 'N/A';
  const parts = sku.split('-');
  return parts[0];
}

function addVariantToCart(variantId, productTitle, variantTitle) {
  const quantity = variantQuantities[variantId] || 1;
  
  console.log('=== ADDING VARIANT TO CART ===');
  console.log('VariantId:', variantId);
  console.log('ProductTitle:', productTitle);
  console.log('VariantTitle:', variantTitle);
  console.log('Quantity:', quantity);
  console.log('Search results:', searchResults);
  
  // Find the specific variant data from the loaded variants
  let variantData = null;
  
  // Look through all search results to find the product with this variant
  for (const product of searchResults) {
    console.log('Checking product:', product.title, 'allVariants:', product.allVariants);
    if (product.allVariants) {
      variantData = product.allVariants.find(v => {
        console.log('Comparing variant:', v.id, 'with:', variantId, 'match:', v.id == variantId);
        return v.id == variantId; // Use == for type coercion
      });
      if (variantData) {
        console.log('Found variant data:', variantData);
        break;
      }
    }
  }
  
  if (!variantData) {
    console.error('Variant data not found for ID:', variantId);
    console.log('Available variant IDs:', searchResults.flatMap(p => p.allVariants || []).map(v => v.id));
  }
  
  // Create product object with the correct variant data
  const product = {
    id: variantId,
    title: productTitle,
    variant: variantTitle,
    sku: variantData ? variantData.sku : '',
    price: variantData ? parseFloat(variantData.price) : 0,
    variantId: variantId,
    handle: '',
    image: '',
    available: true
  };
  
  console.log('Final product object:', product);
  
  addToCart(product, quantity);
  // Keep results open; close handled by outside click listener. Optionally keep input value.
  // document.getElementById('search-input').value = '';
  
  showAddSuccess(productTitle + ' (' + variantTitle + ')', quantity);
}

// Initialize
updateCartDisplay();
  </script>

{% schema %}
  {
    "name": "Cart Builder",
    "target": "section",
    "settings": [
      { "type": "product", "id": "product", "label": "product", "autofill": true },
      { "type": "color", "id": "colour", "label": "Star Colour", "default": "#ff0000" },
      {
        "type": "select",
        "id": "text_size",
        "label": "Text Size",
        "options": [
          { "value": "small", "label": "Small" },
          { "value": "medium", "label": "Medium" },
          { "value": "large", "label": "Large" }
        ],
        "default": "small"
      },
      {
        "type": "text",
        "id": "excluded_tag",
        "label": "Excluded Product Tag",
        "info": "Products with this tag will be excluded from search results. Leave empty to show all products.",
        "default": "PROGRAM"
      }
    ]
  }
  {% endschema %}
  
